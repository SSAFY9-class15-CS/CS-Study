## Synchronization

- **Process Synchronization** : ë©€í‹° í”„ë¡œì„¸ìŠ¤ í™˜ê²½ì—ì„œ í”„ë¡œì„¸ìŠ¤ë“¤ì´ **ìì›ì„ ê³µìœ **í•˜ë©° í˜‘ë ¥í•˜ëŠ” ê²½ìš° í”„ë¡œì„¸ìŠ¤ë“¤ ê°„ì˜ **ì‹¤í–‰ ìˆœì„œë¥¼ ì¡°ì •**í•˜ëŠ” ê²ƒ â‡’ ê³µìœ  ìì›ì˜ **ì¼ê´€ì„±**ì„ ìœ ì§€í•œë‹¤!
- ê³µìœ  ìì›ì„ ì‚¬ìš©í•˜ëŠ” ìƒí™© ì¤‘ context switchingì´ ì¼ì–´ë‚˜ë©´ ê³µìœ  ìì› ê°’ì´ ë’¤ì„ì¼ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ë™ê¸°í™”ê°€ ë“±ì¥
- ì“°ë ˆë“œ, í”„ë¡œì„¸ìŠ¤ ëª¨ë‘ ë™ê¸°í™”ë¥¼ í•„ìš”ë¡œ í•œë‹¤.


> ğŸ’¡ **schedulingì€ ì–¸ì œ ì–´ë””ì„œë“  ë°œìƒí•  ìˆ˜ ìˆë‹¤ëŠ” ì „ì œë¥¼ ìƒê°í•˜ì!**


## Synchronization Problem

- **race condition** : ì—¬ëŸ¬ ê°œì˜ í”„ë¡œì„¸ìŠ¤/ì“°ë ˆë“œê°€ ìì›ì„ ê³µìœ í•  ë•Œ ì‹¤í–‰í•  ë•Œë§ˆë‹¤ ê²°ê³¼ê°€ ë‹¬ë¼ì§€ëŠ” ê²½ìš°ë¥¼ ì˜ë¯¸ â‡’ **ë¹„ì •ìƒì ì´ë‹¤, ì˜ˆì¸¡ê³¼ ë‹¤ë¥¸ ê²°ê³¼ë¥¼ ë‚³ì„ ìˆ˜ ìˆë‹¤.**
- í´ë˜ì‹í•œ ë™ê¸°í™” ì˜ˆì œì¸ Bank Account ì˜ˆì œë¥¼ ì‚´í´ë³´ì.
    - Context Switching ëª¨ìŠµ
        
        ![Untitled (10)](https://user-images.githubusercontent.com/81673820/233978900-1edf2f0c-0d8b-497a-b60b-d3320e32297f.png)
        
    - withdraw ë©”ì†Œë“œ
        
        ```c
        int withdraw(account, amount){ // í˜„ê¸ˆ ì¸ì¶œ ë©”ì†Œë“œ, account:ê³„ì¢Œ, amount:ì¸ì¶œì•¡
        	balance = get_balance(acoount); // 1. balanceë¼ëŠ” ë³€ìˆ˜ì— ê³„ì¢Œ ì”ì•¡ ì €ì¥
        	balance = balance - amount;     // 2. balanceë¥¼ ì¸ì¶œì•¡ë§Œí¼ ë¹¼ì¤Œ
        	put_balance(account, balance);  // 3. ì¸ì¶œì•¡ë§Œí¼ ëº€ balanceë¥¼ ê³„ì¢Œì˜ ì”ì•¡ìœ¼ë¡œ ê°±ì‹ 
        	return balance;                 // 4. ê°±ì‹ ëœ ì”ì•¡ return
        }
        ```
        
    - A, Bë¼ëŠ” ì‚¬ëŒ(í”„ë¡œì„¸ìŠ¤)ì´ ì€í–‰ì—ê°€ì„œ í˜„ê¸ˆì„ ì¸ì¶œí•˜ëŠ” ìƒí™©ì„ ìƒìƒí•´ë³´ì. ì„œë¡œ ë‹¤ë¥¸ ATMê¸°ì—ì„œ ë¨¼ì € Aë¼ëŠ” ì‚¬ëŒì´ í˜„ê¸ˆì„ ì¸ì¶œí•˜ê³  Bë¼ëŠ” ì‚¬ëŒì´ ê±°ì˜ ë™ì‹œì— í˜„ê¸ˆì„ ì¸ì¶œí•œë‹¤. ì´ë•Œ ì€í–‰ ì „ì‚° ì‹œìŠ¤í…œì€ í˜„ê¸ˆ ì¸ì¶œ ë©”ì†Œë“œ(withdraw)ë¥¼ í†µí•´ ì¸ì¶œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì§„í–‰í•˜ëŠ”ë° ìœ„ ê·¸ë¦¼ê³¼ ê°™ì´ Aë¼ëŠ” ì‚¬ëŒì˜ ì‘ì—…ì„ ìˆ˜í–‰í•˜ë˜ ë„ì¤‘ context switchingì´ ë°œìƒí•˜ì—¬ Bì˜ ì‘ì—…ì„ ìˆ˜í–‰í•˜ê²Œ ëœë‹¤ë©´ Aì˜ ì”ì•¡ì´ ì—‰ë§ì´ ë˜ëŠ” **ì˜ˆìƒì¹˜ ëª»í•œ ê²°ê³¼ê°€ ë°œìƒ**í•˜ê²Œ ëœë‹¤.
    - ê·¸ ì´ìœ ëŠ” balanceë¼ëŠ” ìì›ì„ A, B ë‘ í”„ë¡œì„¸ìŠ¤ê°€ **ê³µìœ **í•˜ê¸° ë•Œë¬¸ì´ë‹¤. Aì˜ ì‘ì—…ì„ ìˆ˜í–‰ ë„ì¤‘ context switchingì´ ì¼ì–´ë‚˜ Bê°€ ê³µìœ  ìì›ì¸ balanceì˜ ê°’ì„ ìˆ˜ì •í•˜ê³  ë‹¤ì‹œ context switchingì´ ë˜ì–´ cpuê°€ Bê°€ ìˆ˜ì •í•œ  balance ê°’ì„ ì§€ë‹Œ ì±„ Aê°€ ì´ì „ê¹Œì§€ ìˆ˜í–‰í•œ ì´í›„ ì½”ë“œ ë¶€í„° ì‘ì—…ì„ ìˆ˜í–‰í•˜ê¸° ë•Œë¬¸ì´ë‹¤.
    
- ë™ê¸°í™”ëŠ” í”„ë¡œì„¸ìŠ¤ ê°„ ê³µìœ  ìì›ì´ ì¡´ì¬í•  ë•Œ í•„ìš”í•˜ë‹¤.
    - ex) buffer, queue, list
- count++ ì´ë¼ëŠ” í•œ ì¤„ ì§œë¦¬ ì½”ë“œë„ ì—¬ëŸ¬ ê°œì˜ machine instructionìœ¼ë¡œ êµ¬ì„±ë˜ê³  ì´ ì‚¬ì´ì—ë„ context switchingì´ ì¼ì–´ë‚  ìˆ˜ ìˆë‹¤.
    - ex) load, add, storeâ€¦


> ğŸ’¡ Javaì˜ `SimpleDateFormat` í´ë˜ìŠ¤ thread-unsafeí•´ì„œ ë°˜ë“œì‹œ ë™ê¸°í™”ê°€ í•„ìš”í•˜ë‹¤.


## Critical Sections(ì„ê³„ ì˜ì—­)

- í”„ë¡œì„¸ìŠ¤/ì“°ë ˆë“œ ê°„ ê³µìœ í•˜ê³  ìˆëŠ” ë©”ëª¨ë¦¬ ì˜ì—­ì´ë‚˜ íŒŒì¼ì— ì ‘ê·¼í•˜ëŠ” í”„ë¡œê·¸ë¨ ì˜ì—­ì„ ì˜ë¯¸í•˜ê³  í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤/ì“°ë ˆë“œë§Œì´ ì§„ì…í•  ìˆ˜ ìˆë‹¤.
- êµ¬ì„± ìš”ì†Œ
    - `entry` : critical sectionì— ë“¤ì–´ê°€ê¸° ì§ì „ ì˜ì—­ìœ¼ë¡œ critical sectionì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ”ì§€ ì—¬ë¶€ í™•ì¸
    - `critical section` : ê³µìœ  ìì›ì„ ì‚¬ìš©í•˜ëŠ” ì˜ì—­
    - `exit` : cirtical sectionì—ì„œ ë‚˜ì˜¨ ì§í›„ ì˜ì—­
    - `remainder` : critical section ì´ì™¸ì˜ ì˜ì—­

## Synchronizationì‹œ í•„ìš” ì¡°ê±´

- **Mutual Exclusion(ìƒí˜¸ ë°°íƒ€ì )**
    - **critical sectionì€ í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤/ì“°ë ˆë“œ**ë§Œ ìˆ˜í–‰ ì¤‘ì´ì–´ì•¼ í•œë‹¤.
    - critical sectionì„ ìˆ˜í–‰í•˜ë ¤ëŠ” ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ë“¤ì€ entryì—ì„œ ëŒ€ê¸°í•œë‹¤.
- Solutionsë“¤ì´ ë§Œì¡±í•´ì•¼í•˜ëŠ” ì¡°ê±´
    1. **Mutual exclusion** : critical sectionì—ëŠ” í•œ í”„ë¡œì„¸ìŠ¤ ë˜ëŠ” ì“°ë ˆë“œë§Œ ì¡´ì¬í•´ì•¼í•œë‹¤.
    2. **Progress** : critical section ë°–ì— ìˆëŠ” í”„ë¡œì„¸ìŠ¤ê°€ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ critical sectionì— ë“¤ì–´ê°€ëŠ” ê±¸ ë§‰ìœ¼ë©´ ì•ˆëœë‹¤, critical sectionì„ ì•„ë¬´ë„ ì‚¬ìš©ì¤‘ì´ì§€ ì•Šë‹¤ë©´ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤ë¼ëŠ” ì˜ë¯¸ì™€ ë™
        1. ex. ë‘ ê°œì˜ í”„ë¡œì„¸ìŠ¤ê°€ critical sectionì— ë“¤ì–´ê°€ëŠ” ì†ë„ê°€ ë‹¤ë¥¼ ë•Œ ëŠë¦° ì†ë„ì— ë¹ ë¥¸ ì†ë„ì˜ í”„ë¡œì„¸ìŠ¤ê°€ ë§ì¶°ì•¼ í•˜ëŠ” ê²½ìš°ê°€ ì—†ì–´ì•¼ í•œë‹¤. 
    3. **Bounded waiting**(no starvation)
        1. critical sectionì— ë“¤ì–´ê°€ê¸° ìœ„í•´ ê¸°ë‹¤ë¦¬ëŠ” í”„ë¡œì„¸ìŠ¤ëŠ” **ë¬´ì¡°ê±´ critical sectionì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆì–´ì•¼ í•œë‹¤**.(ìš°ì„ ìˆœìœ„ê°€ ê³„ì† ë°€ë ¤ì„œ starvationì´ ë°œìƒí•˜ë©´ ì•ˆëœë‹¤.)
    4. **Performance**
        1. synchronizationì— ë„ˆë¬´ ë§ì€ ì‹œê°„ì„ ë‚­ë¹„í•´ì„  ì•ˆëœë‹¤.
        2. bakery algorithmì„ ì‚´í´ë³´ë©´ ë™ê¸°í™”ë¥¼ ìœ„í•´ acquire, release ë©”ì†Œë“œì—ì„œ í•´ì•¼í•˜ëŠ” ì¼ì´ ë„ˆë¬´ ë§ë‹¤.
- Solution ì¢…ë¥˜
    - **Locks**
        - SW(os)ì—ì„œëŠ” Mutex HWì—ì„œëŠ” spinlockì´ ì¡´ì¬
    - **Semaphores**
    - **Monitors**
        - cirtical sectionì„ ì§€ì •í•´ì£¼ë©´ ì»´íŒŒì¼ëŸ¬ê°€ ìë™ìœ¼ë¡œ ë™ê¸°í™” ì‹œì¼œì£¼ëŠ” ê²ƒ
    - **Messages**
        - í”„ë¡œì„¸ìŠ¤ Pê°€ Qì— ë©”ì„¸ì§€ë¥¼ ë³´ë‚´ê³  í”„ë¡œì„¸ìŠ¤ Qê°€ Pë¡œ ë¶€í„° ë©”ì„¸ì§€ë¥¼ ë°›ì•„ì•¼ë§Œ í”„ë¡œì„¸ìŠ¤ Qì˜ ì½”ë“œë“¤ì´ ìˆ˜í–‰ â‡’ ìˆœì„œê°€ ë°œìƒ

## Locks

- lockì€ ë‘ ê°œì˜ operationì„ ì œê³µí•˜ëŠ” objectë¡œ íŠ¹ì • ìƒíƒœë¥¼ ì§€ë‹Œë‹¤ .
- operation ì¢…ë¥˜
    - `acquire()`
        - lock ìì›ì„ ì•„ë¬´ë„ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ lockì„ íšë“í•˜ê³  lock ìì›ì˜ ìƒíƒœë¥¼ ì‚¬ìš© ì¤‘(used)ì´ë¼ê³  í‘œì‹œ
        - lock ìì›ì„ ëˆ„êµ°ê°€ ì‚¬ìš© ì¤‘ì´ë¼ë©´ lock ìì›ì´ freeê°€ ë  ë•Œê¹Œì§€ ëŒ€ê¸°
        
        
        > ğŸ’¡ **spin lock** : lock ìì›ì´ freeì¸ì§€ ê³„ì†í•´ì„œ í”„ë¡œì„¸ìŠ¤ê°€ ì§ì ‘ í™•ì¸(busy wait)
        **blocking lock(mutex)** : osê°€ lock ìì›ì´ freeê°€ ë˜ë©´ í”„ë¡œì„¸ìŠ¤ë¥¼ ê¹¨ì›Œì¤Œ
        
        
        
    - `release()`
        - lockì„ ë‹¤ ì“°ê³ ë‚˜ì„œ lockì„ ë†“ì•„ì£¼ê³  lock ìì›ì˜ ìƒíƒœë¥¼ freeë¼ê³  í‘œì‹œ
- ì‚¬ìš© ë°©ë²•
    - lock ì²˜ìŒ ìƒì„± ì‹œ ìƒíƒœë¥¼ feeë¡œ ì´ˆê¸°í™”
    - critical section ì§„ì… ì „ì—ëŠ” acquire, ë‚˜ê°ˆ ë•ŒëŠ” releaseí˜¸ì¶œ
    - lockì„ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ ì‚¬ìš© ì¤‘ì´ë¼ë©´ acquireí•˜ê¸° ìœ„í•´ì„  ëŒ€ê¸°í•´ì•¼í•œë‹¤.
- ë™ì‘ ê³¼ì •
    
    ![Untitled (10-2)](https://user-images.githubusercontent.com/81673820/233978922-c9868bb5-d91a-4307-819b-5b85100dd72b.png)
    
    - critical sectionì— í•œ í”„ë¡œì„¸ìŠ¤ë§Œ ì§„ì…í•˜ê²Œ ëœë‹¤.
    - S1, S2, S3ë¥¼ í•œ ë©ì–´ë¦¬ë¡œ ë¬¶ì–´ **transaction**ì´ë¼ê³  ë¶€ë¥¸ë‹¤.
- ìœ ì˜í•  ì 
    - acquire ìì²´ë„ ì—¬ëŸ¬ machine instructionìœ¼ë¡œ êµ¬ì„±ë˜ë¯€ë¡œ **ê·¸ ì‚¬ì´ì— timer interruptê°€ ì¼ì–´ë‚˜ context switchingì´ ì¼ì–´ë‚  ìˆ˜ ìˆë‹¤**. â‡’ atomic(ì›ìì„±)í•˜ê²Œ acquire ë©”ì†Œë“œë¥¼ êµ¬í˜„í•´ì•¼ í•œë‹¤!
- êµ¬í˜„ ë°©ë²•
    - softwareì  êµ¬í˜„ ë°©ë²•
    - hardwareì  êµ¬í˜„ ë°©ë²•
    - timer-interruptë¥¼ í™œì„±, ë¹„í™œì„±í™”

## Atomic Hardware Instructions

- lockì„ í•˜ë“œì›¨ì–´ ì (cpu level)ìœ¼ë¡œ êµ¬í˜„í•œ ë°©ë²•
    
    ```c
    void struck lock {
    	int value = 0;
    }
    
    void acquire(struct lock *I) {
    	while(TestAndSet(&I- > value));
    }
    
    void release(struck lock *I) {
    	I- > value = 0;
    }
    ```
    
    - test-and-set ì‚¬ìš©í•œ ì˜ˆ
- **atomic instruction**ì„ ì‚¬ìš©
    - read-modify-writeë¥¼ í•˜ë‚˜ì˜ machine cycleë¡œ ìˆ˜í–‰(by OS)
    - test-and-set, compare-and-swapë“±ì´ ì¡´ì¬
        
        ```c
        int TestAndSet(int *v) { //test-and-set êµ¬í˜„ ëª¨ìŠµ
        	int rv = *v;
        	*v = 1;
        	return rv;
        }
        ```
        
- ë‹¨ì 
    - **spinning lock**ì€ ****busy waiting(lockì„ íšë“í•  ìˆ˜ ìˆëŠ” ì§€ ê³„ì† í™•ì¸)í•˜ê¸° ë•Œë¬¸ì— cpu ë‚­ë¹„ê°€ ì‹¬í•˜ë‹¤
        - **busy waiting** : ë§›ì§‘ ì•ì—ì„œ ê³„ì† ë‚´ ìˆœë²ˆì´ ì˜¬ ë•Œ ê¹Œì§€ ëŒ€ê¸° í•˜ëŠ” ê²ƒ ê³¼ ìœ ì‚¬í•˜ì—¬ ì‹œê°„(CPU)ì´ ë‚­ë¹„ëœë‹¤
        - lock, semaphore, monitor ë“±ì€ í…Œì´ë¸”ë§ ì•±ì— ë²ˆí˜¸ë¥¼ ì €ì¥í•˜ê³  ë‚´ ìˆœë²ˆ ë•Œ ì—°ë½ì´ì˜¤ë©´ ì°¾ì•„ê°€ëŠ” ê²ƒê³¼ ìœ ì‚¬í•˜ì—¬ ì‹œê°„(CPU)ì´ ë‚­ë¹„ë˜ì§€ ì•ŠëŠ”ë‹¤.
    - critical sectionì´ ê¸¸ ìˆ˜ë¡ ë‚­ë¹„ê°€ ë”ìš± ì‹¬í•´ì§„ë‹¤.
- ìœ„ ë‹¨ì ë“¤ì— ì˜í•´ lockì€ ì»¤ë„ ì•ˆì—ì„œ ì•„ì£¼ ì§§ì€ critical section êµ¬ê°„ì— ì§„ì…í•  ë•Œë§Œ ì‚¬ìš©í•œë‹¤.(ì¼ë°˜ ì–´í”Œë¦¬ì¼€ì´ì…˜ì—ì„œëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.)

## Disabling Interrupts

- ì•„ì˜ˆ context switchingì´ ì¼ì–´ë‚˜ì§€ ì•Šë„ë¡ timer interruptë¥¼ ë§‰ì•„ë²„ë¦¬ëŠ” ë°©ë²•
- ì£¼ë¡œ ì»¤ë„ ì•ˆì—ì„œë§Œ ì‚¬ìš©(ì¼ë°˜ ì–´í”Œë¦¬ì¼€ì´ì…˜ì—ì„œëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.)
- ë©€í‹° í”„ë¡œì„¸ì„œ í™˜ê²½ì—ì„œëŠ” ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤.
    - í”„ë¡œì„¸ì„œê°€ ì—¬ëŸ¬ ê°œë©´ í•˜ë‚˜ì˜ í”„ë¡œì„¸ì„œì—ì„œë§Œ timer interruptê°€ êº¼ì§€ê¸° ë•Œë¬¸ì—

## Synchronization Types

- **Mutual Exclusion**
    - critical sectionì—ëŠ” ì˜¤ì§ í•˜ë‚˜ì˜ ì“°ë ˆë“œë§Œì´ ì§„ì…í•  ìˆ˜ ìˆë‹¤.
- **Waiting for events**
    - waiting
    - producer/consumer
    - pipeline
    - defer work with background thread

## Higher level Synchronization

- ë“±ì¥ë°°ê²½
    - ì•ì„œ ë°°ìš´ Spinlock, Disabling interruptsëŠ” cpuì˜ performanceë¥¼ ë–¨ì–´ëœ¨ë¦°ë‹¤.
    - ì¼ë°˜ì ìœ¼ë¡œ user-levelì—ì„œ ì‚¬ìš©í•˜ê¸° ë³´ë‹¤ëŠ” kernel-levelì—ì„œ ì‚¬ìš©(ì•„ì£¼ ì§§ì€ ìˆœê°„ ë™ê¸°í™”ê°€ í•„ìš”í•  ë•Œ)
    - ì´ëŸ¬í•œ ì´ìœ  ë•Œë¬¸ì— ë” ì„±ëŠ¥ì´ ì¢‹ì€ synchronization ê¸°ë²•ì´ í•„ìš”í•´ ê³ ìˆ˜ì¤€ì˜ ê¸°ë²•ë“¤ì´ ë“±
- ì¢…ë¥˜
    - Mutex
    - Semaphore
    - Monitor

## Mutex

- OSê°€ ì œê³µí•˜ëŠ” Locking Object(**ê°ì²´**)
    - busy waitingì„ í”¼í•˜ê¸° ìœ„í•´ ë“±ì¥
    - **state(ìƒíƒœ)**ë¥¼ ì§€ë‹˜
        - 0 : ì•„ë¬´ë„ ì‚¬ìš© ì¤‘ì´ì§€ ì•ŠëŠ” ê²½ìš°
        - 1 : ì´ë¯¸ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì— ì˜í•´ ì‚¬ìš© ì¤‘ì¸ ê²½ìš°
- **Operations(ë™ì‘)**
    - `mutex_lock` : lockì„ íšë“, ë§Œì•½ ê³µìœ ìì›ì´ ì´ë¯¸ ì‚¬ìš©ì¤‘ì´ë¼ë©´ freeê°€ ë ë•Œ ê¹Œì§€ cpuë¥¼ ìŠ¤ìŠ¤ë¡œ ë°˜ë‚©(**block**)í•˜ê³  ëŒ€ê¸°
    - `mutex_unlock` : lockì„ ë°˜ë‚©, spin lockê³¼ ë‹¤ë¥´ê²Œ ë°˜ë‚© ì‹œ ê¸°ë‹¤ë¦¬ëŠ” ë‹¤ë¥¸ í”„ë¡œì„¸ë¥¼ ê¹¨ì›Œì¤Œ(**wake up**)

> ğŸ’¡ ê°ì²´ëŠ” **ìƒíƒœ**ì™€ ê·¸ ìƒíƒœë¥¼ ì¡°ì‘í•˜ëŠ” **ë™ì‘(**í–‰ìœ„)ìœ¼ë¡œ êµ¬ì„±ëœë‹¤.


- kernel operations for Mutex
    - `block()` : ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ ìì‹ ì„ ê¹¨ì›Œì¤„ ë•Œ ê¹Œì§€ cpuë¥¼ ë°˜ë‚©í•˜ê³  ëŒ€ê¸°
    - `wakeup(int pid)` : pidë¥¼ ì¸ìë¡œ ë°›ì•„ waiting queueì— ìˆëŠ” í”„ë¡œì„¸ìŠ¤ë¥¼ ready queueë¡œ ì˜®ê²¨ì¤€ë‹¤(ê¹¨ì›Œì¤Œ)
    
- Mutex ë‚´ë¶€ êµ¬í˜„ ëª¨ìŠµ(ìŠˆë„ ì½”ë“œ)
    
    ```c
    typedef struct{
    	int lock; // lock == 0 : ì•„ë¬´ë„ ì‚¬ìš© ì¤‘ì´ì§€ ì•Šì€ ê²½ìš°, lock == 1 : ëˆ„êµ°ê°€ ì´ë¯¸ ì‚¬ìš©ì¤‘ì¸ ê²½ìš°
    	Queue wq; // í”„ë¡œì„¸ìŠ¤ë“¤ì´ ê¸°ë‹¤ë¦´ waiting queue
    } MUTEX;
    
    mutex_lock(MUTEX *m){ // lock ìì›ì„ íšë“
    
    	if(m->lock == 0){ // ì•„ë¬´ë„ lockì„ ì‚¬ìš© ì¤‘ì´ì§€ ì•Šë‹¤ë©´
    		m->lock = 1;
    	} else{  // ì´ë¯¸ ëˆ„êµ°ê°€ lockì„ ì‚¬ìš© ì¤‘ì´ë¼ë©´
    		m->wq.enqueue(getpid());
    		block();
    	}
    	return;
    }
    
    mutex_unlock(MUTEX *m){ // lockìì›ì„ ë°˜ë‚©
    
    	if(!m->wq.isEmpty()){ // lockì„ ì–»ê¸° ìœ„í•´ ê¸°ë‹¤ë¦¬ëŠ” í”„ë¡œì„¸ìŠ¤ê°€ ì¡´ì¬í•œë‹¤ë©´
    		wakeup(m->wq.dequeue());
    	}
    	m->lock = 0; // lock ë°˜ë‚©
    	return;
    }
    
    ```
    
    - mutex_lock, mutex_unlock ì•ˆì—ì„œ lockì˜ ê°’ì„ ë³€ê²½í•˜ëŠ” ë„ì¤‘ context switchingì´ ì¼ì–´ë‚˜ì§€ ì•Šë„ë¡ ë‚´ë¶€ì ìœ¼ë¡œ **Test and Set** or **Interrupt disable**ì„ ì‚¬ìš©í•œë‹¤.
    
> ğŸ’¡ ë©€í‹° ì½”ì–´ í™˜ê²½ì—ì„œ critical sectionì—ì„œì˜ ì‘ì—…ì´ context swtiching ë³´ë‹¤ ë” ë¹¨ë¦¬ ëë‚œë‹¤ë©´ spin lockì´ mutexë³´ë‹¤ ë” ì¢‹ì„ ìˆ˜ ìˆë‹¤.(ì‹±ê¸€ ì½”ì–´ì—ì„œëŠ” ë¬´ì¡°ê±´ mutexê°€ ë”  ì¢‹ë‹¤)


## Semaphores

- Mutex ë³´ë‹¤ í’ë¶€í•œ í‘œí˜„(ê¸°ëŠ¥)ì„ ì œê³µí•˜ëŠ” synchronization ê¸°ë²•
    - ê³µìœ  ìì›ì´ **ì—¬ëŸ¬ ê°œ**ì¸ ê²½ìš°ì—ë„ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•˜ë‹¤.
    - ex. ê³µì¤‘í™”ì¥ì‹¤(ê³µìœ í•˜ëŠ” ì˜ì—­)ì— ì—¬ëŸ¬ ì‚¬ëŒë“¤ì´ ì‚¬ìš©í•˜ëŠ” ë³€ê¸°(ê³µìœ  ìì›)ê°€ ì—¬ëŸ¬ ê°œ ì¡´ì¬
- Dijkstraê°€ ë°œëª…í•œ ê¸°ë²•
- Mutexì™€ ë™ì¼í•˜ê²Œ íŠ¹ì •í•œ **ìƒíƒœ(state)**ì™€ **ë™ì‘(method, operation)**ì„ ì§€ë‹ˆëŠ” **ê°ì²´(object)**ì´ë‹¤.
    - stateëŠ” user programì— ì˜í•´ ì§ì ‘ ì ‘ê·¼í•˜ì—¬ ìˆ˜ì •ë  ìˆ˜ ì—†ë‹¤. â‡’ ì˜¤ë¡œì§€ semaphoreê°€ ì œê³µí•˜ëŠ” operationì„ ì‚¬ìš©í•´ì„œ ìˆ˜ì • í•´ì•¼ í•œë‹¤.
    - Operation
        - `S_wait()`
            - valueë¥¼ ê°ì†Œ ì‹œí‚´
            - ë§Œì•½ ê°ì†Œ ì‹œí‚¨ ê°’ì´ ìŒìˆ˜ê°€ ë  ê²½ìš°(ì‚¬ìš©ê°€ëŠ¥í•œ ìì›ì´ ì—†ëŠ” ê²½ìš°) valueê°€ 0ì´ìƒì´ ë  ë•Œ ê¹Œì§€ wait
        - `S_signal()`
            - valueë¥¼ ì¦ê°€ ì‹œí‚´
            - ë§Œì•½ ì¦ê°€ ì‹œí‚¨ ê°’ì´ ì—¬ì „íˆ ìŒìˆ˜ì¼ ê²½ìš°(ê¸°ë‹¤ë¦¬ëŠ” í”„ë¡œì„¸ìŠ¤ê°€ ì¡´ì¬) ëŒ€ê¸°ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ë¥¼ ê¹¨ì›€
- í”„ë¡œì„¸ìŠ¤/ì“°ë ˆë“œì˜ **ì‹¤í–‰ ìˆœì„œ**ë¥¼ ê²°ì •í•  ë•Œ ì‚¬ìš©í•˜ê¸°ë„ í•œë‹¤.

- Semaphore ë‚´ë¶€ êµ¬í˜„ ëª¨ìŠµ(ìŠˆë„ ì½”ë“œ)
    
    ```c
    typedef struc{
    	int value; // ê³µìœ  ìì›ì˜ ê°œìˆ˜ë¡œ ì´ˆê¸°í™” ë˜ì´ìˆë‹¤.(ê³µìœ ìì›ì´ 3ê°œë¼ë©´ 3ìœ¼ë¡œ ì´ˆê¸°í™”)
    	struct process *Q;
    }
    
    void S_wait(semaphore *S){ // ì„¸ë§ˆí¬ì–´ íšë“
    	S->vlaue--; // ì„¸ë§ˆí¬ì–´ ê°’ ê°ì†Œ
    	if(S->value < 0){  // ì´ë¯¸ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ë“¤ì´ ì‚¬ìš© í•´ì„œ í˜„ì¬ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê³µìœ  ìì›ì´ ì—†ë‹¤ë©´
    		add this process to S->Q  // í˜„ì¬ í”„ë¡œì„¸ìŠ¤ë¥¼ waiting queueì— ì¶”ê°€
    		block();  // cpuë¥¼ ë°˜ë‚©í•˜ê³  ëŒ€ê¸°
    	}
    }
    
    void S_signal(semaphore *S){ // ì„¸ë§ˆí¬ì–´ ë°˜ë‚©
    	S->value++; // ì„¸ë§ˆí¬ì–´ ê°’ ì¦ê°€
    	if(S->value <= 0){ // ì„¸ë§ˆí¬ì–´ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ëŒ€ê¸° ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ê°€ ì¡´ì¬í•œë‹¤ë©´ ì´ë¥¼ ê¹¨ì›Œì¤€ë‹¤.
    		remove a process P from S->Q;
    		wakeup(P); // waiting queueì— ìˆëŠ” í”„ë¡œì„¸ìŠ¤ë¥¼ ê¹¨ì›Œì¤Œ
    	}
    }
    ```
    
    - S_wait, S_signal ì•ˆì— ëª…ë ¹ì„ ìˆ˜í–‰ ì¤‘ context switchingì´ ì¼ì–´ë‚˜ì§€ ì•Šë„ë¡ ë‚´ë¶€ì ìœ¼ë¡œ **Atmoic Instruction** or **Interrupt disable**ì„ ì‚¬ìš©í•œë‹¤.
    - waiting queueì˜ sizeëŠ” ì„¸ë§ˆí¬ì–´ë¥¼ íšë“í•˜ê¸° ìœ„í•´, ì¦‰ ê³µìœ  ìì›ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ê¸°ë‹¤ë¦¬ëŠ” í”„ë¡œì„¸ìŠ¤/ì“°ë ˆë“œì˜ ìˆ˜ì´ë‹¤.

## Types of Semaphores

- **Binary Semaphore**
    - mutexì™€ ìœ ì‚¬(ë‹¨ì§€ ìƒíƒœë¥¼ ì–´ë–»ê²Œ ê·œì •í•˜ëŠëƒë§Œ ì°¨ì´ê°€ ì¡´ì¬)
    - ìì›ì´ í•˜ë‚˜ ë¿ì¸ ê²½ìš° ì‚¬ìš©
    - ì´ˆê¸°ê°’ì„ 1ë¡œ ì„¤ì •
- **Counting Semaphore**
    - ì²´ìœ¡ì‹œê°„ì— ë†êµ¬ê³µì— ë¹„ìœ 
    - ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ìì›ì´ ì—¬ëŸ¬ ê°œì¸ ê²½ìš°
    - ì´ˆê¸°ê°’ì„ Nìœ¼ë¡œ ì„¤ì •(N : ìì›ì˜ ê°œìˆ˜)
- **Mutexì™€ Binary Semaphoreì˜ ì°¨ì´ì **
    1. mutexëŠ” lockì„ ê°€ì§„ í”„ë¡œì„¸ìŠ¤ë§Œì´ lockì„ í•´ì œí•  ìˆ˜ ìˆì§€ë§Œ semaphoreëŠ” ê·¸ë ‡ì§€ ì•Šë‹¤.
    2. mutexëŠ” **priority inheritance** ì†ì„±ì„ ì§€ë‹ˆì§€ë§Œ ì„¸ë§ˆí¬ì–´ëŠ” ê·¸ëŸ¬í•œ ì†ì„±ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤.(ì„¸ë§ˆí¬ì–´ë¥¼ ì§€ë‹Œ ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ ì¤‘ ëˆ„ê°€ signalì„ ë‚ ë¦´ ì§€ ì•Œ ìˆ˜ ì—†ê¸° ë•Œë¬¸ì—)


> ğŸ’¡ mutal exclusionë§Œ í•„ìš”í•˜ë‹¤ë©´ Mutex, ì‘ì—… ê°„ì˜ ì‹¤í–‰ ìˆœì„œë¥¼ ì§€ì •í•´ì¤˜ì•¼ í•œë‹¤ë©´  Binary Semaphore ì‚¬ìš©


## Bounded Buffer Problem

- Producer/Consumer Problemì´ë¼ê³ ë„ ë¶ˆë¦°ë‹¤.
    - producerëŠ” ìì›(ë°ì´í„°)ì„ ë²„í¼ì— ë„£ëŠ” ì—­í• 
    - consumerëŠ” ìì› ë²„í¼ì—ì„œ ë¹¼ëŠ” ì—­í• 
- ì œí•œëœ í¬ê¸°ë¥¼ ê°–ëŠ” ë²„í¼ë¥¼ producerì™€ consumerê°€ ê³µìœ  â‡’ ë™ê¸°í™” í•„ìš”
- producerì™€ consumerê°€ ë°ì´í„°ë¥¼ ë„£ê³  ë¹¼ëŠ” ì†ë„ê°€ ë‹¤ë¥´ë‹¤ â‡’ ë™ê¸°í™” í•„ìš”
- **ë™ê¸°í™” í•˜ê¸° ì „ ëª¨ìŠµ(ìŠˆë„ ì½”ë“œ)**
    
    ```c
    struct item buffer[N]; // ë°ì´í„°ë¥¼ ë‹´ê±°ë‚˜ ëº„ ë²„í¼
    int in, out; // in : ë‹¤ìŒì— ë°ì´í„°ë¥¼ ë„£ì„ index, out : ë‹¤ìŒì— ë°ì´í„°ë¥¼ ëº„ index
    int count;   // count : í˜„ì¬ ë²„í¼ì— ë“¤ì–´ìˆëŠ” ë°ì´í„°ì˜ ê°œìˆ˜
    
    void Producer(data){ // ë°ì´í„° ìƒì„±
    	
    	while(count != N){ // bufferì— ë°ì´í„°ê°€ ê½‰ ì°¼ëŠ”ì§€ í™•ì¸
    		buffer[in] = data;
    		in = (in+1) % N;
    		count++;
    	}
    }
    
    void Consumer(data){ // ë°ì´í„° ì¡°íšŒ
    	
    	while(count != 0){ // ë²„í¼ì— ë°ì´í„°ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    		data = buffer[out];
    		out = (out+1) % N;
    		count--;
    	}
    }
    
    ```
    
    - produer, consumerê°€ ì—¬ëŸ¬ ê°œ ìˆì„ ë•Œ producerë“¤ ê°„ `in` ë³€ìˆ˜ë¥¼, consumerë“¤ ê°„ `out` ë³€ìˆ˜ë¥¼ **ê³µìœ **í•˜ë¯€ë¡œ **ë™ê¸°í™”**ê°€ í•„ìš”
    - whileë¬¸ì„ ì‚¬ìš©í•˜ì—¬ **busy waiting**í•˜ê¸° ë•Œë¬¸ì— **cpuê°€ ë‚­ë¹„ë¨**

- **ì„¸ë§ˆí¬ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ë™ê¸°í™” í•œ ì˜ˆì œ(ìŠˆë„ ì½”ë“œ)**
    
    ```c
    Semaphore mutex = 1; // binary semaphore, producerë“¤, consumerë“¤ ê°„ in, out ë³€ìˆ˜ì˜ ë™ê¸°í™”
    Semaphore empty = N; // counting semaphore, ë°ì´í„°ë¥¼ ë„£ì„ ìˆ˜ ìˆëŠ” ë¹ˆ ê³µê°„ì„ ì˜ë¯¸
    Semaphore full = 0;  // counting semaphore, ë°ì´í„°ê°€ ì±„ì›Œì ¸ ëº„ ìˆ˜ ìˆëŠ” ê³µê°„ì„ ì˜ë¯¸
    
    struct item buffer[N]; // ë°ì´í„°ë¥¼ ë‹´ê±°ë‚˜ ëº„ ë²„í¼
    int in, out; // in : ë‹¤ìŒì— ë°ì´í„°ë¥¼ ë„£ì„ index, out : ë‹¤ìŒì— ë°ì´í„°ë¥¼ ëº„ index
    int count;   // count : í˜„ì¬ ë“¤ì–´ìˆëŠ” ë°ì´í„°ì˜ ê°œìˆ˜
    
    void Producer(data){ // ë°ì´í„° ìƒì„±
    	S_wait(&empty);    // bufferì— ë°ì´í„°ë¥¼ ì±„ì›Œ ë„£ì„ ë¹ˆ ê³µê°„ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    	S_wait(&mutex);    // bufferë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì§€ í™•ì¸(producerë“¤ ê°„ ë™ê¸°í™”)
    	buffer[in] = data;
    	in = (in+1) % N;
    	count++;
    	S_signal(&mutex);  // buffer ì‚¬ìš© ê¶Œí•œ ë°˜ë‚©
    	S_signal(&full);   // bufferì— ë°ì´í„°ê°€ ìƒì„±ë˜ì—ˆë‹¤ê³  ì•Œë¦¼
    }
    
    void Consumer(data){ // ë°ì´í„° ì¡°íšŒ
    	S_wait(&full);     // bufferì— ë°ì´í„°ê°€ ì¡´ì¬í•˜ëŠ” ì§€ í™•ì¸
    	S_wait(&mutex);    // bufferë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì§€ í™•ì¸(readerë“¤ ê°„ ë™ê¸°í™”)
    	data = buffer[out];
    	out = (out+1) % N;
    	count--;
    	S_signal(&mutex);  // buffer ì‚¬ìš© ê¶Œí•œ ë°˜ë‚©
    	S_signal(&empty);  // bufferì— ë°ì´í„°ë¥¼ ì±„ì›Œ ë„£ì„ ë¹ˆ ê³µê°„ì´ ì¡´ì¬í•œë‹¤ê³  ì•Œë¦¼
    }
    
    ```
    
    - entry sectionì—ì„œ empty semaphore ë˜ëŠ” full semaphore ê°’ì´ 0 ì´í•˜ì¼ ë•Œ íŠ¹ì • í”„ë¡œì„¸ìŠ¤ê°€ `S_wait`ì„ í˜¸ì¶œí•  ê²½ìš° ë‚´ë¶€ì ìœ¼ë¡œ sys call `block`ì„ í˜¸ì¶œí•˜ì—¬ waiting ìƒíƒœì— ë“¤ì–´ê°„ë‹¤.
    - ì‘ì—… ì™„ë£Œ ì‹œ exit sectionì—ì„œ `S_signal`ì„ í†µí•´ waiting ìƒíƒœì— ìˆëŠ” í”„ë¡œì„¸ìŠ¤ë¥¼ ê¹¨ì›Œì¤€ë‹¤.
    

## Reader-Writers Problem

- ë™ê¸°í™”ë¥¼ í•˜ì§€ ì•Šì„ ê²½ìš° ë°œìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ì œì ì„ ë³´ì—¬ì£¼ëŠ” ëŒ€í‘œì ì¸ ì˜ˆì œ ì¤‘ í•˜ë‚˜ë¡œ ì—¬ëŸ¬ ê°œì˜ í”„ë¡œì„¸ìŠ¤/ì“°ë ˆë“œë“¤ì´ ê³µìœ í•˜ëŠ” ë²„í¼ì— ë°ì´í„°ë¥¼ ì½ê±°(Reader)ë‚˜ ì“°ê¸°(Writer) ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤.
- ì„¸ë§ˆí¬ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ Reader & Writer Problemì„ ë™ê¸°í™” í•œ ì˜ˆì œ
    
    ```c
    int readCount = 0;   // í˜„ì¬ ëª‡ ëª…ì˜ readerê°€ dataë¥¼ ì½ëŠ” ì§€
    Semaphore readerSemaphore = 1;    // ì—¬ëŸ¬ readerë“¤ ê°„ ê³µìœ í•˜ëŠ” ë°ì´í„°ì— ëŒ€í•œ ë™ê¸°í™” ìˆ˜í–‰
    Semaphore readWriteSemaphore = 1; // readerì™€ writerê°„ ê³µìœ í•˜ëŠ” ë°ì´í„°ì— ëŒ€í•œ ë™ê¸°í™” ìˆ˜í–‰
    
    void Writer(){
    	S_wait(&readWriteSemaphore);  // ë°ì´í„°ë¥¼ ìƒì„±í•  bufferì— ì ‘ê·¼í•  ê¶Œí•œì„ íšë“, ì´ë¯¸ ì‚¬ìš©ì¤‘ì´ë¼ë©´ waiting queueë¡œ ì´ë™
    	...
    	Write Data
    	...
    	S_signal(&readWriteSemaphore); // ì‘ì—… ì™„ë£Œ í›„ ë°ì´í„°ê°€ ë‹´ê¸´ bufferì— ì ‘ê·¼í•  ê¶Œí•œì„ ë°˜ë‚© í›„ waiting queueì—ì„œ ëŒ€ê¸°ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ë¥¼ êº ì›Œì¤Œ
    }
    
    void Reader(){
    	S_wait(&readerSemaphore); // readerë“¤ ê°„ ê³µìœ í•˜ëŠ” readCount ìì›ì˜ ì‚¬ìš© ê¶Œí•œì„ íšë“í•˜ê¸° ìœ„í•´ readerSemaphore wait
    	readCount++:
    
    	if(readCount == 1){ // ë§Œì•½ ì²« ë²ˆì§¸ readerë¼ë©´ ë°ì´í„°ë¥¼ ì½ì„ bufferì— ì ‘ê·¼í•  ê¶Œí•œì„ íšë“, ì²« ë²ˆì§¸ readerê°€ ì•„ë‹ˆë¼ë©´ ì´ë¯¸ ì–»ì–´ì ¸ ìˆê¸° ë•Œë¬¸ì— ë„˜ì–´ê°€ë„ ëœë‹¤.
    		S_wait(&readWriteSemaphore);
    	}
    
    	S_signal(&readerSemaphore); // readerSemaphore ë°˜ë‚©
    	...
    	Read Data
    	...
    	S_wait(&readerSemaphore);  // readCountë¥¼ ìˆ˜ì •í•˜ê¸° ìœ„í•´ readerSemaphore wait
    
    	readCount--;
    
    	if(readCount == 0){ // ë§Œì•½ ëª¨ë“  readerê°€ ì‘ì—…ì„ ì¢…ë£Œí–ˆë‹¤ë©´ bufferì— ì ‘ê·¼í•  ê¶Œí•œì„ ë°˜ë‚© í›„ waiting queueì—ì„œ ëŒ€ê¸°ì¤‘ì¸ writerë¥¼ êº ì›Œì¤Œ
    		S_signal(&readWriteSemaphore);
    	}
    
    	S_signal(&readerSemaphore);  // readerSemaphore ë°˜ë‚©
    }
    
    ```
    
    - writerëŠ” ë°ì´í„°ì˜ ìˆ˜ì •(create, update)ì´ ì¼ì–´ë‚˜ì„œ í•œ ë²ˆì— í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤/ì“°ë ˆë“œë§Œì´ bufferì— ì ‘ê·¼ ê°€ëŠ¥í•˜ë‹¤.
    - readerëŠ” ë‹¨ì§€ ë°ì´í„°ë¥¼ ì½ê¸°(read)ë§Œ í•˜ê¸° ë•Œë¬¸ì— ë³€ê²½ì´ ì¼ì–´ë‚˜ì§€ ì•Šì•„ í•œ ë²ˆì— ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤/ì“°ë ˆë“œê°€ ì ‘ê·¼ ê°€ëŠ¥í•˜ë‹¤.
    - reading í•˜ëŠ” ì¤‘ì— writingì´ ë¶ˆê°€ëŠ¥í•˜ê³  writing í•˜ëŠ” ì¤‘ì— readingì´ ë¶ˆê°€ëŠ¥í•´ì•¼ í•œë‹¤.

## Dining Philosophers Problem

- ì² í•™ì : í”„ë¡œì„¸ìŠ¤
- í¬í¬ : ì»´í“¨í„° ìì›(íŒŒì¼, ë©”ëª¨ë¦¬â€¦)
- ì² í•™ìëŠ” ì–‘ìª½ì— ìˆëŠ” í¬í¬ë¥¼ ì§‘ì–´ì•¼ ì‹ì‚¬ê°€ ê°€ëŠ¥í•œë° ëª¨ë“  ì² í•™ìë“¤ì´ ë™ì‹œì— ì™¼ìª½ í˜¹ì€ ì˜¤ë¥¸ìª½ì— ìˆëŠ” í¬í¬ë¥¼ ì§‘ì–´ë“¤ê³  ì™¼ìª½ í¬í¬ë¥¼ ë‹¤ë¥¸ ì² í•™ìê°€ ë‹¤ ì“¸ ë•Œ ê¹Œì§€ ê¸°ë‹¤ë¦°ë‹¤ë©´ ì˜ì›íˆ ê¸°ë‹¤ë¦¬ê²Œ ëœë‹¤. â‡’ Dead Lockì´ë¼ê³  ë¶€ë¥¸ë‹¤.(Dead Lock free solutionì— ëŒ€í•´ì„œëŠ” ì¶”í›„ ë‹¤ë£° ì˜ˆì •)
- Dead Lock Free Solution
    
    ![Untitled (12)](https://user-images.githubusercontent.com/81673820/233978936-9061582b-e2ce-4878-be7d-3a94ea0926c6.png)
    
    - í•œ ëª…ë§Œ ì˜¤ë¥¸ ìª½ í¬í¬ë¶€í„° ì§‘ê³  ì™¼ìª½ í¬í¬ë¥¼ ì§‘ê²Œ í•˜ê³  ë‚˜ë¨¸ì§€ëŠ” ì™¼ìª½ í¬í¬ë¶€í„° ì§‘ë„ë¡ í•œë‹¤ë©´ dead lockì´ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.

## Using Semaphores

- **ì¥ì **
    - mutexì˜ ì—­í• (bianry semaphore)ê³¼ counting semaphore ì—­í•  ëª¨ë‘ ìˆ˜í–‰ ê°€ëŠ¥í•˜ë‹¤.
    - í•˜ì§€ë§Œ ì—­í• ì„ ë¶„ëª…íˆ í•˜ê¸° ìœ„í•´ì„œ binary semaphoreë¥¼ ì‚¬ìš©í•˜ê¸°ë³´ë‹¨ mutexë¥¼ ì‚¬ìš©í•˜ëŠ” ê²Œ ì¢‹ë‹¤.(counting semaphoreì™€ êµ¬ë¶„í•˜ê¸° ìœ„í•´)
- **ë‹¨ì **
    - í”„ë¡œê·¸ë¨ ì½”ë“œ ì—¬ê¸°ì €ê¸°ì—ì„œ semaphoreì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤. (semaphoreëŠ” ê²°êµ­ ê°ì²´ì´ê¸° ë•Œë¬¸ì— ì£¼ì†Œê°’ë§Œ ì•Œë©´ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤)
    - ì‚¬ìš©ì´ ë³µì¡í•˜ë‹¤

## Condition Variables

- í”„ë¡œì„¸ìŠ¤ê°€ mutexë¥¼ ì–»ì€ í›„ critical sectionì— ë“¤ì–´ì™€ ì‘ì—…ì„ ìˆ˜í–‰ ì¤‘ ë§Œì¡±í•´ì•¼í•˜ëŠ” íŠ¹ì • ì¡°ê±´ì´ ë§Œì¡±ë˜ì§€ ì•Šì•„ ëŒ€ê°œí•´ì•¼í•˜ëŠ” ìƒí™©ì´ ë°œìƒ ì‹œ, ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ë“¤ì´ critical sectinoì— ë“¤ì–´ì™€ ì‘ì—…ì„ í•  ìˆ˜ ìˆë„ë¡ mutexë¥¼ ë°˜ë‚©í•˜ê³  blockë˜ë„ë¡ í•œë‹¤.
- condition variableì€ **waiting queue**ë¼ê³  ìƒê°í•˜ë©´ í¸í•˜ë‹¤.
- operations
    - `wait()`
        - ìì‹ ì´ ê°€ì§€ê³  ìˆë˜ mutex lockì„ ë°˜ë‚©
        - ëˆ„êµ°ê°€ ê¹¨ì›Œì¤„ ë•Œ ê¹Œì§€ ëŒ€ê¸°
        - ìœ„ ë‘ ë™ì‘ì€ atomic í•˜ê²Œ ë™ì‘í•œë‹¤.
    - `signal()`
        - waiting queueì—ì„œ ëŒ€ê¸°í•˜ëŠ” ê°€ì¥ ì•ì— ìˆëŠ”(ì˜¤ë˜ëœ) í”„ë¡œì„¸ìŠ¤ë¥¼ ê¹¨ì›Œì¤Œ
        - í”„ë¡œì„¸ìŠ¤ê°€ ê¹¨ì›Œë‚¬ë‹¤ê³  í•´ì„œ ë°”ë¡œ mutexë¥¼ ì–»ëŠ” ê²Œ ì•„ë‹ˆë¼ ë‹¤ì‹œ mutexë¥¼ íšë“í•˜ê¸° ìœ„í•´ ê¸°ë‹¤ë¦¬ê²Œ ëœë‹¤.
    - `broadcast()`
        - waiting queueì—ì„œ ëŒ€ê¸°í•˜ëŠ” ëª¨ë“  í”„ë¡œì„¸ìŠ¤ë“¤ì„ ê¹¨ì›Œì¤Œ

## CV Semantics

- **Mesa semantics(Signal and Continue)**
    - signalì„ ë³´ë‚´ waiting threadë¥¼ ê¹¨ìš°ë©´ waiting threadëŠ” ready queueë¡œ ê°€ê²Œë˜ê³ , caller threadëŠ” ì—¬ì „íˆ critical sectionì„ ìˆ˜í–‰í•  ìˆ˜ë„ ìˆë‹¤.
    - waiting threadê°€ ê¹¨ì–´ë‚˜ë©´ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ë“¤ì— ì˜í•´ ê¸°ë‹¤ë¦¬ë˜ ì¡°ê±´ì˜ ìƒíƒœê°€ ë³€í•  ìˆ˜ë„ ìˆë‹¤. â‡’ waiting threadê°€ ìì‹ ì´ ê¸°ë‹¤ë¦¬ë˜ ì¡°ê±´ì´ ë§Œì¡±ë˜ì—ˆëŠ”ì§€ **ë‹¤ì‹œ check**í•´ë´ì•¼ í•œë‹¤.
    - OSì—ì„œëŠ” Mesa semanticsë¥¼ ì‚¬ìš©í•œë‹¤.
    - Bounded Buffer Problem with Mesa semantics
        
        ![Untitled (13)](https://user-images.githubusercontent.com/81673820/233978938-76a99443-58ca-45af-91a2-180e9dd41675.png)
        
        - ì¡°ê±´ì„ ë‹¤ì‹œ checkí•´ë´ì•¼í•˜ì§€ë§Œ ê·¸ë ‡ì§€ ì•Šê³  ë°”ë¡œ ë‹¤ìŒ ì½”ë“œë¥¼ ìˆ˜í–‰í•˜ê¸° ë•Œë¬¸ì— whileë¬¸ì„ ifë¡œ ë°”ê¾¸ê²Œ ë˜ë©´ ë¶ˆì•ˆì •í•œ ìƒíƒœì— ë¹ ì§ˆ ìˆ˜ ìˆë‹¤.
        - Hoare semantcisì¼ ê²½ìš° ifë¡œ í•´ë„ ê°€ëŠ¥í•˜ë‹¤.
        
- **Hoare semantics(Signal and Wait)**
    - ë§¤ìš° ì—„ê²©
    - signalì„ ë³´ë‚¼  callerì™€ waiting threadë¥¼ ë°”ë¡œ switichingí•œë‹¤.(waiting threadê°€ cpuë¥¼ ë°”ë¡œ ì–» ,callerëŠ” block ìƒíƒœ ì§„ì…) â‡’ waiting threadê°€ signalë¡œ ê¹¨ì–´ë‚˜ë©´ ë°”ë¡œ mutexë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤.
    - ì¡°ê±´ì´ ë°”ë€” ê°€ëŠ¥ì„±ì´ ì—†ë‹¤. â‡’ waiting threadê°€ **ì¡°ê±´ì´ ë§Œì¡±**ëë‹¤ê³  í™•ì‹ í•  ìˆ˜ ìˆë‹¤ .
    - **overhead**ê°€ í¬ê³  êµ¬í˜„í•˜ê¸° ì–´ë µë‹¤.

## Using Broadcast

- Cì–¸ì–´ì˜ ë™ì í• ë‹¹ ì‹œ ì‚¬ìš©í•˜ëŠ” `malloc`ì˜ ëŒ€ëµì ì¸ ë™ì‘ ê³¼ì •ì„ ë³´ì—¬ì¤€ë‹¤.
    
    ![Untitled (14)](https://user-images.githubusercontent.com/81673820/233978941-aaa45650-2fe4-4049-af08-04b805d477cc.png)
    
- ì‹œê·¸ë„ì„ ë³´ë‚´ëŠ” í”„ë¡œì„¸ìŠ¤ê°€ waiting queueì—ì„œ ëŒ€ê¸° ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ ì¤‘ ì–´ë–¤ í”„ë¡œì„¸ìŠ¤ë¥¼ ê¹¨ì›Œì•¼í•  ì§€ ëª¨ë¥´ëŠ” ê²½ìš° `boradcast`ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ë“¤ì„ ê¹¨ìš°ê³  ê° í”„ë¡œì„¸ìŠ¤ë“¤ì´ ìì‹ ì´ ê¸°ë‹¤ë¦¬ë˜ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ”ì§€ **re check**í•˜ë„ë¡ í•œë‹¤.

## Monitor

- í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì—ì„œ ì œê³µí•˜ëŠ” êµ¬ì¡°ì²´(ê°ì²´)
- ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ë“¤ì´ ê³µìœ í•˜ëŠ” ê³µìœ  ì •ë³´(ë³€ìˆ˜)ì™€ ê³µìœ  ì •ë³´ì— ì ‘ê·¼í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” procedure(ë©”ì†Œë“œ, operations)ë¡œ êµ¬ì„±ëœë‹¤.
- ê³µìœ ìì›ì— ì ‘ê·¼í•˜ëŠ” ì˜ì—­ì„ ì›ë˜ëŠ” ê°œë°œìê°€ synchronizationì„ í•´ì•¼í•˜ì§€ë§Œ monitor ì‚¬ìš© ì‹œ **ì»´íŒŒì¼ëŸ¬ê°€ ìë™**ìœ¼ë¡œ í•´ì¤€ë‹¤.
- monitorëŠ” ë‚´ë¶€ì ìœ¼ë¡œ **mutex**ì™€ **condition variable**ì„ ì‚¬ìš©í•˜ì—¬ synchronizationì„ ìˆ˜í–‰í•œë‹¤.
- êµ¬ì¡°
    
    ![Untitled (15)](https://user-images.githubusercontent.com/81673820/233978942-7f252ad0-f155-4264-bda4-7afdffcbd54e.png)
    
    1. monitorë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ **mutex**ë¥¼ íšë“í•´ì•¼ í•˜ë¯€ë¡œ ì´ë¯¸ ëˆ„êµ°ê°€ê°€ ì‚¬ìš©ì¤‘ì´ë¼ë©´ **entry queue**ì—ì„œ ëŒ€ê¸°
    2. monitorì•ˆì— ë“¤ì–´ì™€ operationì„ ìˆ˜í–‰ ì¤‘ íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•  ë•Œ ê¹Œì§€ ê¸°ë‹¤ë ¤ì•¼ í•˜ëŠ” ìƒí™©ì´ ì˜¨ë‹¤ë©´ ê°€ì§€ê³  ìˆë˜ mutexë¥¼ ë°˜ë‚©í•˜ê³  monitorì•ˆì— ìˆëŠ” **condtion variable(waiting queue)**ì—ì„œ ëŒ€ê¸°

> ğŸ’¡ entry queue, waiting queue ì•ˆì—ì„œì˜ í”„ë¡œì„¸ìŠ¤/ì“°ë ˆë“œ ê°„ ìˆœì„œëŠ” ìŠ¤ì¼€ì¥´ë§ ìš°ì„ ìˆœìœ„ì— ë”°ë¥¸ë‹¤.


## Javaì—ì„œì˜ Synchronization

- ëª¨ë“  ìë°” í´ë˜ìŠ¤ì—ëŠ” í•˜ë‚˜ì˜ **monitor(mutex + condition variable)**ê°€ ì¡´ì¬í•œë‹¤.
- ë¬µì‹œì ìœ¼ë¡œ í´ë˜ìŠ¤ ë‹¹ ê¸°ë³¸ì ìœ¼ë¡œ í•˜ë‚˜ì˜ condition variableì„ ì§€ë‹Œë‹¤.
    - condition variableì„ ë” í•„ìš”ë¡œ í•œë‹¤ë©´ ëª…ì‹œì ìœ¼ë¡œ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.
- mutual exculsion ì‚¬ìš© ì‹œ `synchronized` í‚¤ì›Œë“œë¥¼ ë¶™ì—¬ì¤€ë‹¤.
- Bounded Buffer Problem
    
    ```java
    class BoundedBuffer{
    	volatile Buffer q; // ë°ì´í„°ë¥¼ ì…ë ¥í•˜ê±°ë‚˜ ì†Œë¹„í•  ë²„í¼
    	int first = 0; // first : ë°ì´í„°ë¥¼ êº¼ë‚¼ ì§€ì  
    	int last = 0;  // last : ë°ì´í„°ë¥¼ ë„£ì„ ì§€ì 
    	
    	public synchronized void producer(int item){ // ì»´íŒŒì¼ëŸ¬ê°€ synchronized í‚¤ì›Œë“œë¥¼ ë³´ê³  mutexë¡œ procedureë¥¼ ê°ì‹¸ì¤Œ
    		while((last - first) == N){ // ë°ì´í„°ë¥¼ ë„£ì„ ë¹ˆ ê³µê°„ì´ ì¡´ì¬í•˜ëŠ” ì§€ í™•ì¸
    			wait();
    		}
    
    		buff[last % N] = item;
    		notify(); // ë²„í¼ì— ë°ì´í„°ê°€ ìƒì„±ë˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ë˜ í”„ë¡œì„¸ìŠ¤ë¥¼ ê¹¨ì›€
    		last++;
    	}
    	
    	public synchronized int consumer(int item){
    		while(last == first){ // ë²„í¼ì— ë°ì´í„°ê°€ ì¡´ì¬í•˜ëŠ” ì§€ í™•ì¸
    			wait();
    		}
    		
    		int item = buff[first % N];
    		first++:		
    		notify(); // ë²„í¼ì— ë¹ˆ ê³µê°„ì´ ìƒê¸°ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ë˜ í”„ë¡œì„¸ìŠ¤ë¥¼ ê¹¨ì›€
    		return item;	
    	}
    
    }
    ```
    
    ```java
    global volatile Buffer q;
    global Lock mutex;
    global CV fullCV;
    global CV emptyCV;
    
    public method producer(){
    	while(true){
    		task MyTask = ...;
    
    		mutex.acquire();  // monitorë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•œ mutex íšë“
    	
    		while(q.isFull){  // ë°ì´í„°ë¥¼ ì“¸ ê³µê°„ì´ ì—†ë‹¤ë©´ mutex ë°˜ë‚© í›„ fullCVì—ì„œ ëŒ€ê¸°
    			wait(lock, fullCV);
    		}
    
    		q.enqueue(myTask); // ë²„í¼ì— ë°ì´í„° ìƒì„±
    
    		signal(emptyCV); -- or-- boradcast(emptyCV); // ë²„í¼ì— ë°ì´í„°ê°€ ìƒì„±ë˜ì—ˆìœ¼ë¯€ë¡œ emptyCVì—ì„œ ëŒ€ê¸°ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ë¥¼ ê¹¨ì›Œì¤Œ
    
    		mutex.release(); // mutex ë°˜ë‚©
    	}
    }
    
    public method consumer(){
    	while(true){
    		mutex.acquire();  // monitorë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•œ mutex íšë“
    
    		while(q.isEmpty()){ // ë²„í¼ ë‚´ ë°ì´í„°ê°€ ì—†ë‹¤ë©´ mutex ë°˜ë‚© í›„ fullCVì—ì„œ ëŒ€ê¸°
    			wait(lock, emptyCV);
    		}
    
    		myTask = q.dequeue(); // ë°ì´í„° ì†Œë¹„
    
    		signal(fullCV); --or-- broadcast(fullCV); // ë²„í¼ì— ë°ì´í„°ë¥¼ ì“¸ ë¹ˆ ê³µê°„ì´ ìƒê²¼ìœ¼ë¯€ë¡œ fullCVì—ì„œ ëŒ€ê¸°ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ë¥¼ ê¹¨ì›Œì¤Œ
    
    		mutex.release();  // mutex ë°˜ë‚©
    		
    		doStuff(myTask);  // êº¼ë‚¸ ë°ì´í„°ë¡œ ì‘ì—… ìˆ˜í–‰
    	}
    }
    ```
    
    - `wait` : condition variableì˜ waitì™€ ë™ì¼
    - `notify` : condition variableì˜ signalê³¼ ë™ì¼
    - `notifyall` : condition variableì˜ broadcastì™€ ë™ì¼